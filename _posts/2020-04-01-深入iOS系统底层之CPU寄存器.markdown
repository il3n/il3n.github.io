---
layout: post
title:  "深入iOS系统底层之CPU寄存器"
date:   2023-06-30 10:54:23 +0800
categories: ios
---

[深入iOS系统底层之CPU寄存器](https://juejin.im/post/5a786c555188257a6854b18c)
[iOS调试进阶](https://zhuanlan.zhihu.com/p/31168191)
[Procedure Call Standard for the Arm® 64-bit Architecture](https://developer.arm.com/docs/ihi0055/latest/procedure-call-standard-for-the-arm-64-bit-architecture)

## 指令中的寄存器

CPU执行的每条指令都由操作码和操作数组成。在CPU内部要运算的数据总是放在寄存器中，而实际的数据则有可能放在内存或者IO端口中，因此，程序实际上大部分事件再做下面3件事：

1. 把内存或者IO端口的数据读取到寄存器
2. 把寄存器的数据进行运算（运算只能在寄存器中运行）
3. 将寄存器的内容写回到内存或者IO端口

## 寄存器的分类

arm64体系的CPU提供了37个64位通用寄存器；x64体系下的CPU提供16个64位通用寄存器。

- 对于x64体系的CPU来说，如果寄存器以`r`开头则表明是一个64位的寄存器，如果以`e`开头则表明是一个32位的寄存器。同时系统还提供了16位和8位的寄存器。
- 对于arm64体系的CPU来说，如果寄存器以`x`开头，则表明是一个64位寄存器，如果以`w`开头，表明是一个32位寄存器。

寄存器按照作用分类如下：

### 数据地址寄存器

通常用来做数据计算的临时存储、做累加、计数、地址保存等功能。定义这些寄存器的主要作用是用于在CPU指令中保存操作数。在CPU中当做常规变量来使用。

| 体系结构 | 长度 | 名称 |
| :-: | :-: | :-: |
| x64 | 64 | RAX, RBX, RCX, RDX, RDI, RSI, R8-R15 |
| x64 | 32 | EAX, EBX, ECX, EDX, EDI, ESI, R8D-R15D | 
| x64 | 16 | AX, BX, CX, DX, DI, SI, R8W-R15W |
| x64 | 8 | AL, BL, CL, DL, DIL, SIL, R8L-R15L |
| arm64 | 64 | X0-X30, XZR |
| arm64 | 32 | W0-W30, WZR | 

- 在x64体系中`RAX`及arm64体系中`X0`一般都用来保存函数返回值。
- 在函数调用时的参数传递在x64体系中分别保存在`RDI`，`RSI`, `RDX`, `RCX`, `R8`, `R9`, ...；而在arm64体系中分别保存在`X0`, `X1`,...中
- arm64体系中的`XZR`, `WZR`表示为一个特殊的寄存器
- arm64体系中的`X8`一般用来表示全局变量或者常量的偏移地址。而`X16`，`X17`则有特殊的用途，一般用来保存间接调用时的函数地址。
- arm64中的`X29`用于保存函数栈的基址寄存器，`X29`也叫做`FP`，一般不能用于其他用途。

### Intel架构CPU的段寄存器

为了保存操作系统进入用户态还是核心态以及进行用户态和核心态之间切换上下文数据的功能。

| 体系结构 | 长度 | 名称 |
| :-: | :-: | :-: |
| x64 | 16 | CS, DS, SS, ES, FS, GS | 


### 栈寄存器

维护一个栈需要有2个寄存器，一个用来保存基地址，一个用来保持栈顶。通常情况下，栈的基地址在内存高地址，栈顶在内存低地址。
在x64体系的CPU中，提供了一个专门的`RBP`寄存器来保存栈的基地址，同时提供`RSP`寄存器保存栈顶；
在arm64中，没有专门的栈基地址寄存器，一般使用`X29`保存，使用`SP`寄存器来保存栈顶。

| 体系结构 | 长度 | 名称 |
| :-: | :-: | :-: |
| x64 | 64 | RBP为栈基址寄存器，RSP为栈顶寄存器 |
| x64 | 32 | EBP为栈基址寄存器，ESP为栈顶寄存器 |
| x64 | 16 | BP为栈基址寄存器，SP为栈顶寄存器 |
| arm64 | 64 | X29为栈基址寄存器，SP为栈顶寄存器 |
| arm64 | 32 | W29为栈基址寄存器，WSP为栈顶寄存器 |

### 浮点和向量寄存器

浮点数寄存器：
| 体系结构 | 长度 | 名称 |
| :-: | :-: | :-: |
| x64 | 128 | XMM0-XMM15 |
| arm64 | 64 | D0-D31 |
| arm64 | 32 | S0-S31 |

向量寄存器：
图像处理等
| 体系结构 | 长度 | 名称 |
| :-: | :-: | :-: |
| x64 | 128 | XMM0-XMM15, YMM0-YMM15, STMM0-STMM7 |
| arm64 | 128 | V0-V31 |

### 状态寄存器
报错指令运行结果信息，比如是否溢出、结果是否为0，是否为负数等。状态寄存器的内容由CPU内部进行置位。
| 体系结构 | 长度 | 名称 |
| :-: | :-: | :-: |
| x64 | 64 | RFLAGS |
| arm64 | 32 | CPSR |

### 指令寄存器（程序计数器）

CPU根据指令寄存器中记录的地址到内存中读取指令，并执行，同时将下条指令的内存地址保存到指令寄存器。

2个问题：

1. CPU内不是有高速缓存吗，怎么这里说保存的是内存地址？指令寄存器确实保存的是下一条指令在内存中的地址，但操作系统除了将部分内存区域中的指令保存在高速缓存外，还会建立一个内存地址到高速缓存地址间的映射关系。因此，虽然指令寄存器保存的是内存地址，但在执行的时候，CPU会根据指令寄存器中的内存地址及映射关系在高速缓存中读取指令。如果发现指令不存在，则会触发中断，通知操作系统从内存中读取所需的内存数据到高速缓存中。
2. 如果指令寄存器每次都是保存的顺序执行指令的话，如何实现跳转逻辑呢？利用跳转指令和函数调用指令。用户态中的代码不能手动改变指令寄存器的值，但可以利用跳转指令和函数调用指令，间接改变指令执行顺序。

**需要强调的是，指令寄存器保存的是下一条要执行的指令的内存地址，而不是当前正在执行的指令的内存地址**

| 体系结构 | 长度 | 名称 |
| :-: | :-: | :-: |
| x64 | 64 | RIP |
| x64 | 32 | EIP |
| arm64 | 64 | PC, LR |

![PC和LR](https://user-gold-cdn.xitu.io/2018/2/5/161666724b83210a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

`PC`寄存器保存的是下一条指令将要执行的内存地址；
`LR`寄存器保存着最后一次函数调用指令的下一条指令的内存地址；`LR`是为了做函数调用栈的跟踪。

### 其他寄存器

用于控制及调试的寄存器，供操作系统或者CPU内部调试使用。

## 寄存器的编码

![mov指令二进制结构](https://user-gold-cdn.xitu.io/2018/2/5/161666724d2f9ea6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 寄存器查看

**要想打印显示某个寄存器的内容，可以利用`expr`或者`po`命令，在需要显示的寄存器前面加上`$`**

```bash
# 模拟器
expr -o -- $rdi 
expr (char *)$x1

# 真机
expr -o -- $x0
expr (char *)$x1

# 或者
register read x0
register read # 读取所有寄存器的值
register write x10 100 # x10 = 100

expr $r12 = 100; # 改变寄存器的值
```
> `X29`是`FP`，`X30`是`LR`.

### 寄存器的复用

#### 线程切换

操作系统每创建一个线程，都会为这个线程创建一个数据结构来保存这个线程的信息，这个数据结构称为线程上下文。每个线程的上下文中都有一部分数据是用来保存当前所有寄存器的副本。
每当操作系统暂停一个线程时，就会将所有寄存器的值都保存到线程上下文中；并从另一个线程的上下文中读取所有寄存器的值，放入寄存器。下面的部分线程上下文结构就是指定了所有寄存器信息的部分：

```c
//这个结构是linux在arm32CPU上的线程上下文结构，代码来自于：http://elixir.free-electrons.com/linux/latest/source/arch/arm/include/asm/thread_info.h  
//这里并没有保存所有的寄存器，是因为ABI中定义linux在arm上运行时所使用的寄存器并不是全体寄存器，所以只需要保存规定的寄存器的内容即可。这里并不是所有的CPU所保存的内容都是一致的，保存的内容会根据CPU架构的差异而不同。
//因为iOS的内核并未开源所以无法得到iOS定义的线程上下文结构。

//线程切换时要保存的CPU寄存器，
struct cpu_context_save {
    __u32   r4;
    __u32   r5;
    __u32   r6;
    __u32   r7;
    __u32   r8;
    __u32   r9;
    __u32   sl;
    __u32   fp;
    __u32   sp;
    __u32   pc;
    __u32   extra[2];       /* Xscale 'acc' register, etc */
};

//线程上下文结构
struct thread_info {
    unsigned long       flags;      /* low level flags */
    int         preempt_count;  /* 0 => preemptable, <0 => bug */
    mm_segment_t        addr_limit; /* address limit */
    struct task_struct  *task;      /* main task structure */
    __u32           cpu;        /* cpu */
    __u32           cpu_domain; /* cpu domain */
    struct cpu_context_save cpu_context;    /* cpu context */
    __u32           syscall;    /* syscall number */
    __u8            used_cp[16];    /* thread used copro */
    unsigned long       tp_value[2];    /* TLS registers */
#ifdef CONFIG_CRUNCH
    struct crunch_state crunchstate;
#endif
    union fp_state      fpstate __attribute__((aligned(8)));  /*浮点寄存器*/
    union vfp_state     vfpstate;  /*向量浮点寄存器*/
#ifdef CONFIG_ARM_THUMBEE
    unsigned long       thumbee_state;  /* ThumbEE Handler Base register */
#endif
};
```
![线程切换](https://user-gold-cdn.xitu.io/2018/2/5/1616667285577c1e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 函数调用

同样的问题也会出现在函数调用上。解决的办法是由编译器在编译出机器指令时按照一定的规则进行编译（这是一种ABI规则）。

```c
void  foo2()
{
     int a = 20;
     a = a + 2;
     int b = 30;
     b = b * 3;
     int  c = a + b;
}

void foo1()
{
      int a = 10;
      int b = 20;
      int c = 30;
      
      a += 10;
      b += 10;
      c += 10;
      foo2();
     
      c = a + b;
}
```
虽然在foo1和foo2都定义了a,b,c三个变量，但是因为这三个变量分别保存在foo1和foo2的不同栈内存区，因此互相不会影响。
**高级语言里面的每行代码在编译为机器指令时，总是先将数据从内存读取到寄存器中，处理完毕后，立即写回到内存，中间并不将数据缓存到寄存器。**
每次高级语言的赋值处理总是先读取，在计算，在写回。因此，当调用foo2函数前，所有寄存器都是出于空闲的获可以被任意修改的状态。而调用完毕后，再从内存读取到寄存器。运算完毕再立即写入到内存。

上面是针对寄存器复用的两种不同策略：空间换时间和时间换空间。































